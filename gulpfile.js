// Generated by CoffeeScript 1.9.3

/**
 * TMS全局组件库开发构建工具
 * @author [Pang.J.G]
 * @version [0.0.1]
 * @date  [2016-01-15 15:58:53]
 * @required [gulp]
 */
var CleanCSS, REGEX, Tools, _, _cfg, _distPath, _opt, _root, _srcPath, argv, autopre, build, color, crypto, e, fontFiles, fs, gulp, gutil, imagemin, imgFiles, jsFiles, less, lessFiles, log, opts, path, plumber, sprite, through2, uglify, yargs;

fs = require('fs');

path = require('path');

gulp = require('gulp');

_ = require('lodash');

crypto = require('crypto');

yargs = require('yargs');

less = require('gulp-less');

uglify = require('uglify-js');

sprite = require('gulp-sprite-all');

autopre = require('gulp-autoprefixer');

plumber = require('gulp-plumber');

gutil = require('gulp-util');

log = gutil.log;

color = gutil.colors;

CleanCSS = require('clean-css');

through2 = require('through2');

imagemin = require('imagemin-pngquant');

_cfg = {};

try {
  _cfg = require('./config.json');
} catch (_error) {
  e = _error;
  log(e);
}

_root = process.env.INIT_CWD;

_srcPath = './';

_distPath = '../global/';

argv = yargs.option("e", {
  alias: 'env',
  demand: true,
  "default": _cfg.env || 'local',
  describe: color.cyan('项目的运行环境'),
  type: 'string'
}).option("pre", {
  alias: 'prefix',
  "default": _cfg.prefix || 'tms.',
  describe: color.cyan('设置生产文件名的前缀'),
  type: 'string'
}).option("hash", {
  alias: 'hashlen',
  "default": _cfg.hashLen || 10,
  describe: color.cyan('设置生产文件名的hash长度'),
  type: 'number'
}).option("cdn", {
  alias: 'cdndomain',
  "default": _cfg.cdnDomain || '',
  describe: color.cyan('设置项目发布的cdn域名'),
  type: 'string'
}).help('h').alias('h', 'help').argv;

_opt = {
  root: _root,
  srcPath: _srcPath,
  distPath: _distPath,
  srcPaths: {},
  distPaths: {}
};

['less', 'js', 'img', 'font', 'html', 'sprite'].forEach(function(val) {
  return _opt['srcPaths'][val] = _srcPath + val;
});

['css', 'img', 'js', 'font'].forEach(function(val) {
  return _opt['distPaths'][val] = _distPath + val;
});

opts = _.assign({}, argv, _opt);

opts.env = argv.e;

opts.env !== 'www' && (opts.comboDomain = "//" + opts.env + "." + opts.cdn);

opts.mapPath = path.join(opts.distPath, 'globalMap.json');

log(opts);

global.Cache = {};

global.Cache['cssMap'] = {};

global.Cache['jsMap'] = {};

global.Cache['imgMap'] = {};

global.Cache['fontMap'] = {};

REGEX = {
  uri: /globalUri\(('|")([^'|^"]*)(\w+).(png|gif|jpg|html|js|css)('|")\)/g,
  uriVal: /\([\s\S]*?\)/,
  cssBg: /url\([\S\s]*?\)/g
};


/**
 * base functions
 */

Tools = {
  md5: function(source) {
    var _buf, _str;
    _buf = new Buffer(source);
    _str = _buf.toString("binary");
    return crypto.createHash('md5').update(_str, 'utf8').digest('hex');
  },
  mkdirsSync: function(dirpath, mode) {
    if (fs.existsSync(dirpath)) {
      return true;
    } else {
      if (Tools.mkdirsSync(path.dirname(dirpath), mode)) {
        fs.mkdirSync(dirpath, mode);
        return true;
      }
    }
  },
  errHandler: function(e) {
    gutil.beep();
    gutil.beep();
    return log(e);
  },
  getFileSync: function(file, encoding) {
    var _encoding, fileCon, stats;
    _encoding = encoding || 'utf8';
    fileCon = '';
    if (fs.existsSync(file)) {
      stats = fs.statSync(file);
      if (stats.isFile()) {
        fileCon = fs.readFileSync(file, _encoding);
      }
    }
    return fileCon;
  },
  getJSONSync: function(file) {
    var data, fileCon;
    fileCon = Tools.getFileSync(file);
    data = {};
    if (fileCon) {
      fileCon = fileCon.replace(/\/\/[^\n]*/g, '');
      try {
        data = JSON.parse(fileCon);
      } catch (_error) {
        e = _error;
        console.log(e);
      }
    }
    return data;
  },
  minify: function(source, type) {
    var cssOpt, mangled;
    type = type || "js";
    if (type === 'css') {
      cssOpt = {
        keepBreaks: false,
        compatibility: {
          properties: {
            iePrefixHack: true,
            ieSuffixHack: true
          }
        }
      };
      source = Tools._replaceCssBg(source);
      mangled = new CleanCSS(cssOpt).minify(source);
      return mangled.styles;
    } else {
      source = Tools._replaceUriValue(source);
      mangled = uglify.minify(source, {
        fromString: true
      });
      return mangled.code;
    }
  },
  htmlMinify: function(source) {
    var s;
    s = source.replace(/\/\*([\s\S]*?)\*\//g, '').replace(/<!--([\s\S]*?)-->/g, '').replace(/^\s+$/g, '').replace(/\n/g, '').replace(/\t/g, '').replace(/\r/g, '').replace(/\n\s+/g, ' ').replace(/\s+/g, ' ').replace(/>([\n\s]*?)</g, '><');
    return s;
  },
  isWin: function() {
    return process.platform === "win32";
  },
  tranFilePath: function(filePath) {
    var _file;
    _file = filePath || "";
    if (Tools.isWin()) {
      _file = _file.replace(/\\/g, '\/');
    }
    return _file;
  },
  writeFile: function(file, source, offlog) {
    var name;
    name = path.basename(file);
    if (fs.existsSync(file) && Tools.md5(Tools.getFileSync(file)) === Tools.md5(source)) {
      return false;
    }
    Tools.mkdirsSync(path.dirname(file));
    fs.writeFileSync(file, source, 'utf8');
    return offlog || log("'" + color.cyan(path.basename(file)) + "'", "build success.");
  },
  _setDegbugPath: function(parse) {
    parse.base = "debug." + parse.name + parse.ext;
    return path.format(parse);
  },
  _setDistPath: function(parse, hash) {
    parse.base = opts.prefix + parse.name + "." + hash.substring(0, opts.hashLen) + parse.ext;
    return path.format(parse);
  },
  _setSrcPath: function(parse) {
    parse.base = opts.prefix + parse.name + parse.ext;
    return path.format(parse);
  },
  _setCacheType: function(parse) {
    return parse.ext.replace('.', '');
  },
  _getDistName: function(type, name) {
    if (_.has(global.Cache, type + "Map") && global.Cache[type + "Map"][name]) {
      return global.Cache[type + "Map"][name].distPath;
    } else {
      return name;
    }
  },
  _replaceUriValue: function(source) {
    return source.replace(REGEX.uri, function(res) {
      var _val, _valArr, distName, name, type;
      _val = res.match(REGEX.uriVal).shift().replace(/[\(\)"']/g, '');
      _valArr = _val.split('/');
      type = _valArr.shift();
      name = _valArr.join('/');
      distName = Tools._getDistName(type, name);
      return res.replace(name, distName);
    });
  },
  _replaceCssBg: function(source) {
    return source.replace(REGEX.cssBg, function(res) {
      var _val, distName, name;
      _val = res.match(REGEX.uriVal).shift().replace(/[\(\)"']/g, '');
      if (_val.indexOf('font/') !== -1) {
        name = _val.split('font/')[1].split(/(\?|#)/)[0];
        distName = Tools._getDistName('font', name);
        return res.replace(name, distName);
      } else if (_val.indexOf('img/') !== -1) {
        name = _val.split('img/')[1];
        distName = Tools._getDistName('img', name);
        return res.replace(name, distName);
      } else {
        return res;
      }
    });
  },
  throughImg: function(type) {
    var _type;
    _type = type || 'img';
    return through2.obj(function(file, enc, callback) {
      var _contents, _hash, _parse, relative;
      if (file.isNull()) {
        return callback(null, file);
      } else if (file.isStream()) {
        throw new Error('Streams are not supported!');
      }
      relative = file.relative;
      _contents = file.contents;
      _parse = path.parse(relative);
      _hash = Tools.md5(_contents.toString());
      _distPath = Tools._setDistPath(_parse, _hash).replace(opts.prefix, '');
      opts.env !== 'local' && Tools.writeFile(path.join(opts.distPaths[_type], _distPath), _contents, 1);
      global.Cache[_type + "Map"][relative] = {
        hash: _hash,
        distPath: _distPath
      };
      return callback(null, file);
    });
  },
  throughObj: function() {
    return through2.obj(function(file, enc, callback) {
      var _contents, _debugPath, _hash, _minContents, _parse, _type, relative;
      if (file.isNull()) {
        return callback(null, file);
      } else if (file.isStream()) {
        throw new Error('Streams are not supported!');
      }
      relative = file.relative;
      _parse = path.parse(relative);
      _type = Tools._setCacheType(_parse);
      _contents = file.contents;
      _minContents = Tools.minify(_contents.toString(), _type);
      _hash = Tools.md5(_minContents);
      _srcPath = Tools._setSrcPath(_parse);
      _distPath = Tools._setDistPath(_parse, _hash);
      Tools.writeFile(path.join(opts.distPaths[_type], _srcPath), _minContents);
      opts.env !== 'local' && Tools.writeFile(path.join(opts.distPaths[_type], _distPath), _minContents);
      _debugPath = Tools._setDegbugPath(_parse);
      file.path = path.join(opts.distPaths[_type], _debugPath);
      global.Cache[_type + "Map"][relative] = {
        hash: _hash,
        distPath: _distPath
      };
      return callback(null, file);
    });
  },
  tips: function(res) {
    return log("'" + color.cyan(path.basename(res.path)) + "'", color.yellow(res.type) + ".");
  }
};

build = {
  init: function() {
    var _dir, _makePath, key, ref, ref1, results, val;
    log('初始化 global 资源目录');
    _makePath = function(dir) {
      Tools.mkdirsSync(dir);
      return log("'" + color.cyan("" + dir) + "'", "dir made success!");
    };
    ref = opts.srcPaths;
    for (val in ref) {
      key = ref[val];
      _dir = opts.srcPath + val;
      _makePath(_dir);
    }
    _makePath(opts.distPath);
    ref1 = opts.distPaths;
    results = [];
    for (val in ref1) {
      key = ref1[val];
      _dir = opts.distPath + val;
      results.push(_makePath(_dir));
    }
    return results;
  },
  sprite: function(cb) {
    var _cb, spCtrl, spOpts;
    _cb = cb || function() {};
    spOpts = {
      srcPath: opts.srcPaths.sprite,
      lessOutPath: path.join(opts.srcPaths.less, '_sprite'),
      imgOutPath: path.join(opts.srcPaths.img, 'sprite')
    };
    spCtrl = new sprite.init(spOpts);
    return spCtrl.output(function() {
      return _cb();
    });
  },
  font: function(files, cb) {
    var _cb;
    _cb = cb || function() {};
    return gulp.src(files).pipe(plumber({
      errorHandler: Tools.errHandler
    })).pipe(Tools.throughImg('font')).pipe(gulp.dest(opts.distPaths.font)).on('end', function() {
      return _cb();
    });
  },
  img: function(files, cb) {
    var _cb;
    _cb = cb || function() {};
    return gulp.src(files).pipe(plumber({
      errorHandler: Tools.errHandler
    })).pipe(imagemin({
      quality: '65-80',
      speed: 4
    })()).pipe(Tools.throughImg()).pipe(gulp.dest(opts.distPaths.img)).on('end', function() {
      return _cb();
    });
  },
  css: function(files, cb) {
    var _cb, _cssPath, _lessPath;
    _cb = cb || function() {};
    _lessPath = opts.srcPaths.less;
    _cssPath = opts.distPaths.css;
    return gulp.src(files).pipe(plumber({
      errorHandler: Tools.errHandler
    })).pipe(less({
      compress: false,
      paths: [_lessPath]
    })).pipe(autopre()).pipe(Tools.throughObj()).pipe(gulp.dest(_cssPath)).on('end', function() {
      return _cb();
    });
  },
  js: function(files, cb) {
    var _cb, _jsOutPath;
    _cb = cb || function() {};
    _jsOutPath = opts.distPaths.js;
    return gulp.src(files).pipe(plumber({
      errorHandler: Tools.errHandler
    })).pipe(Tools.throughObj()).pipe(gulp.dest(_jsOutPath)).on('end', _cb);
  },
  getMap: function() {
    var map;
    map = Tools.getJSONSync(opts.mapPath);
    return global.Cache = _.assign(global.Cache, map);
  },
  saveMap: function() {
    return Tools.writeFile(opts.mapPath, JSON.stringify(global.Cache, null, 4));
  }
};

fontFiles = [path.join(opts.srcPaths.font, '*.{eot,woff,svg,ttf,otf}')];

imgFiles = [path.join(opts.srcPaths.img, '*.{png,jpg,gif,ico}'), path.join(opts.srcPaths.img, '**/*.{png,jpg,gif,ico}')];

lessFiles = [path.join(opts.srcPaths.less, '*.less'), path.join(opts.srcPaths.less, '**/*.less'), "!" + (path.join(opts.srcPaths.less, '_*.less')), "!" + (path.join(opts.srcPaths.less, '_**/*.less')), "!" + (path.join(opts.srcPaths.less, '_**/**/*.less')), "!" + (path.join(opts.srcPaths.less, '_**/**/**/*.less'))];

jsFiles = [path.join(opts.srcPaths.js, '*.js'), path.join(opts.srcPaths.js, '**/*.js')];

gulp.task('init', function() {
  return build.init();
});

gulp.task('getmap', function() {
  return build.getMap();
});

gulp.task('sprite', ['getmap'], function() {
  return build.sprite();
});

gulp.task('font', ['sprite'], function() {
  return build.font(fontFiles);
});

gulp.task('img', ['font'], function() {
  return build.img(imgFiles);
});

gulp.task('css', ['img'], function() {
  return build.css(lessFiles);
});

gulp.task('js', ['css'], function() {
  return build.js(jsFiles, function() {
    return build.saveMap();
  });
});

gulp.task("watch", function() {
  _.isEmpty(global.Cache['cssMap']) && build.getMap();
  gulp.watch(lessFiles.slice(0, 2), function(res) {
    Tools.tips(res);
    return res.type !== 'deleted' && build.css(lessFiles, function() {
      return build.saveMap();
    });
  });
  gulp.watch(jsFiles, function(res) {
    Tools.tips(res);
    return res.type !== 'deleted' && build.js(res.path, function() {
      return build.saveMap();
    });
  });
  gulp.watch(imgFiles, function(res) {
    Tools.tips(res);
    return res.type !== 'deleted' && build.img(res.path, function() {
      return build.saveMap();
    });
  });
  gulp.watch(fontFiles, function(res) {
    Tools.tips(res);
    return res.type !== 'deleted' && build.font(res.path);
  });
  return gulp.watch(opts.srcPaths.sprite + "**/*.png", function(res) {
    Tools.tips(res);
    return build.sprite();
  });
});

gulp.task('default', ['js'], function() {
  if (opts.env !== 'local') {
    return false;
  }
  return gulp.start('watch');
});
